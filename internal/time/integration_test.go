package time

import (
	"bytes"
	"testing"
	"time"
)

// TestTimeHealth_Integration tests the full time health cycle
func TestTimeHealth_Integration(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping integration test in short mode")
	}

	config := Config{
		Enabled:              true,
		Servers:              []string{"pool.ntp.org"},
		CheckIntervalSeconds: 1, // Short for test
		MaxOffsetSeconds:     5,
		TimeoutSeconds:       5,
	}
	th := NewTimeHealth(config)

	// Start periodic checks
	th.Start()

	// Wait for initial check
	time.Sleep(2000 * time.Millisecond)

	status := th.GetStatus()
	if status.LastCheck.IsZero() {
		t.Error("LastCheck should be set after Start()")
	}

	// Health depends on actual offset - just verify check happened
	_ = status.Healthy
	_ = status.Offset
}

// TestStampBridgeEXIFWithTool_Integration tests EXIF stamping via exiftool
// This test requires exiftool to be installed
func TestStampBridgeEXIFWithTool_Integration(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping integration test in short mode")
	}

	// Check if exiftool is available
	helper, err := DefaultExifToolHelper()
	if err != nil {
		t.Skip("exiftool not available, skipping integration test")
	}

	version, err := helper.GetVersion()
	if err != nil {
		t.Skip("exiftool not working, skipping integration test")
	}
	t.Logf("Using exiftool version: %s", version)

	// Create test observation
	captureTime := time.Date(2024, 12, 25, 10, 30, 0, 0, time.UTC)
	observation := ObservationResult{
		Time:       captureTime,
		Source:     SourceBridgeClock,
		Confidence: ConfidenceHigh,
	}

	// Create minimal valid JPEG
	imageData := createTestJPEGForIntegration()

	// Stamp the image
	result := StampBridgeEXIFWithTool(imageData, observation)

	if !result.Stamped {
		t.Error("Expected image to be stamped")
	}

	// Verify the marker was set correctly
	expectedMarkerPrefix := "AviationWX-Bridge:UTC:v1:bridge_clock:high"
	if result.Marker != expectedMarkerPrefix {
		t.Errorf("Expected marker %q, got %q", expectedMarkerPrefix, result.Marker)
	}

	// Verify the stamped data contains the marker
	if !bytes.Contains(result.Data, []byte("AviationWX-Bridge")) {
		t.Error("Stamped data should contain AviationWX-Bridge marker")
	}

	t.Logf("Successfully stamped image with marker: %s", result.Marker)
}

// TestStampBridgeEXIFWithTool_Warning tests stamping with a warning
func TestStampBridgeEXIFWithTool_Warning(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping integration test in short mode")
	}

	// Check if exiftool is available
	helper, err := DefaultExifToolHelper()
	if err != nil {
		t.Skip("exiftool not available, skipping integration test")
	}
	if !helper.IsAvailable() {
		t.Skip("exiftool not available, skipping integration test")
	}

	// Create test observation with warning
	observation := ObservationResult{
		Time:       time.Now().UTC(),
		Source:     SourceBridgeClock,
		Confidence: ConfidenceLow,
		Warning: &TimeWarning{
			Code:    "ntp_unhealthy",
			Message: "NTP sync failed",
		},
	}

	imageData := createTestJPEGForIntegration()

	result := StampBridgeEXIFWithTool(imageData, observation)

	if !result.Stamped {
		t.Error("Expected image to be stamped")
	}

	// Verify warning is in marker
	expectedSuffix := ":warn:ntp_unhealthy"
	if len(result.Marker) < len(expectedSuffix) || result.Marker[len(result.Marker)-len(expectedSuffix):] != expectedSuffix {
		t.Errorf("Expected marker to end with %q, got %q", expectedSuffix, result.Marker)
	}
}

// createTestJPEGForIntegration creates a minimal valid JPEG for integration tests
func createTestJPEGForIntegration() []byte {
	// Minimal valid JPEG structure that exiftool can process
	return []byte{
		0xFF, 0xD8, // SOI
		0xFF, 0xE0, 0x00, 0x10, // APP0 marker + length
		0x4A, 0x46, 0x49, 0x46, 0x00, // "JFIF\0"
		0x01, 0x01, // version 1.1
		0x00,       // aspect ratio units (0 = no units)
		0x00, 0x01, // X density
		0x00, 0x01, // Y density
		0x00, 0x00, // thumbnail size (0x0)
		0xFF, 0xDB, 0x00, 0x43, 0x00, // DQT marker + length + table 0
		// 64 bytes quantization table (all 16s for simplicity)
		0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
		0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
		0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
		0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
		0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
		0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
		0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
		0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
		0xFF, 0xC0, 0x00, 0x0B, // SOF0 marker + length
		0x08,       // 8 bits per component
		0x00, 0x01, // height = 1
		0x00, 0x01, // width = 1
		0x01,             // 1 component (grayscale)
		0x01, 0x11, 0x00, // component 1: ID=1, sampling=1x1, quant table 0
		0xFF, 0xC4, 0x00, 0x1F, // DHT marker + length
		0x00, // DC table 0
		// Huffman table (counts + symbols for simple DC)
		0x00, 0x01, 0x05, 0x01, 0x01, 0x01, 0x01, 0x01,
		0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
		0x08, 0x09, 0x0A, 0x0B,
		0xFF, 0xC4, 0x00, 0xB5, // DHT marker + length (AC table)
		0x10, // AC table 0
		// AC Huffman table
		0x00, 0x02, 0x01, 0x03, 0x03, 0x02, 0x04, 0x03,
		0x05, 0x05, 0x04, 0x04, 0x00, 0x00, 0x01, 0x7D,
		0x01, 0x02, 0x03, 0x00, 0x04, 0x11, 0x05, 0x12,
		0x21, 0x31, 0x41, 0x06, 0x13, 0x51, 0x61, 0x07,
		0x22, 0x71, 0x14, 0x32, 0x81, 0x91, 0xA1, 0x08,
		0x23, 0x42, 0xB1, 0xC1, 0x15, 0x52, 0xD1, 0xF0,
		0x24, 0x33, 0x62, 0x72, 0x82, 0x09, 0x0A, 0x16,
		0x17, 0x18, 0x19, 0x1A, 0x25, 0x26, 0x27, 0x28,
		0x29, 0x2A, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39,
		0x3A, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49,
		0x4A, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59,
		0x5A, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69,
		0x6A, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79,
		0x7A, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89,
		0x8A, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98,
		0x99, 0x9A, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7,
		0xA8, 0xA9, 0xAA, 0xB2, 0xB3, 0xB4, 0xB5, 0xB6,
		0xB7, 0xB8, 0xB9, 0xBA, 0xC2, 0xC3, 0xC4, 0xC5,
		0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xD2, 0xD3, 0xD4,
		0xD5, 0xD6, 0xD7, 0xD8, 0xD9, 0xDA, 0xE1, 0xE2,
		0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA,
		0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8,
		0xF9, 0xFA,
		0xFF, 0xDA, 0x00, 0x08, // SOS marker + length
		0x01,       // 1 component
		0x01, 0x00, // component 1, DC table 0, AC table 0
		0x00, 0x3F, 0x00, // spectral selection
		0x7F,       // Single gray pixel data (encoded)
		0xFF, 0xD9, // EOI
	}
}
